# Arduino 教程

## 开发环境配置

开始于Arduino

### 1. 安装Windows驱动程序 

![](media/c9ff43ab919d1bd3ceaad6a3275ccb58.png)

安装 Arduino IDE

我们先到arduino
官方的网站<https://www.arduino.cc/>下载最新版本的arduino开发软件,进入网站之后点击界面上的SOFTWARE,选择DOWNLOADS进入下载页面，如下图：

![](media/27dc48fecb3c600bb3cee380a433c0fb.png)

Arduino 软件有很多版本，有windows,mac, linux系统的（如下图），而且还有过去老的版本，你只需要下载一个适合系统的版本。

这里我们以WINDOWS系统的为例给大家介绍一下下载和安装的步骤。

WINDOWS系统的也有两个版本，一个版本是安装版的，一个是下载版的不用安装，直接下载文件到电脑，解压缩就可以用了。

![](media/820ea0396cfbaa8e7c2ba64e98ecd4cd.png)

两个版本都可以正常使用，看你自己的喜好了。选择一个版本，然后将Arduino
开发软件下载到我们的电脑。

![](media/c3f27dec3872ef7e09fea89676b7c7c2.png)

一般情况下，我们点击JUST DOWNLOAD就可以下载了，当然如果你愿意，你可以选择小小的赞助，以帮助伟大的ARDUINO开源事业。

在Windows系统安装开发板驱动文件

接下来是开发板驱动的安装，这次我们安装的是Keyes Uno Plus
开发板的驱动，这个开发板的USB转串口芯片是CP2102。在ARDUINO
开发软件1.8以上的版本里就已经包含了这个芯片的驱动程序，这样我们使用起来会非常方便。（如果你的Arduino开发软件不是1.8以上版本的，就需要到

[https://www.silabs.com/products/development-tools/software/usb-to-uart-bridge-vcp-drivers](https://www.silabs.com/products/development-tools/software/usb-to-uart-bridge-vcp-drivers)

这个地址去下载CP2102的芯片驱动）一般插上USB，电脑就会识别到硬件，WINDOWS就会自动安装CP2102的驱动。

![](media/2d98f8f602d370b6556b7c07d26bd9d2.png)

![](media/cb90d5f0fbe64d25436859f6505c653b.png)

如果驱动安装失败，则需要手动安装驱动。请打开计算机的设备管理器，右键单击“计算机”-----单击“属性”-----单击“设备管理器”。在端口
(COM &LPT)或Other devices下，黄色感叹号表示CP2102驱动程序安装失败。

![](media/8e7d7443586deac6584082f734c2ae20.png)

显示CP2102的驱动没有安装成功，有一个黄色的感叹号。先双击![](media/a2455b26773cb8d6cb3fccc605ea4dd7.png)，再单击“更新驱动程序(U)...”更新驱动。

![](media/90bda8a9bbb56fad1a1f878afa263da1.png)

点击“浏览我的电脑一查找驱动程序(R)”，找到我们安装或者下载的Arduino软件.

![](media/0bce95bf5076fa8328d26c27f7a69eef.png)

在Arduino文件夹（![](media/aae89b3213589edf1c320d5502489820.png)）里面有一个drivers文件夹，打开drivers文件夹就可以看到CP210X系列芯片的驱动。

点击“浏览(R)...”,选中CP210X系列芯片的驱动，点击“下一页”。

![](media/77ae3c54cb7c208c1ecc63c291d4652b.png)

过一会儿，驱动安装成功。点击“关闭”即可。

![](media/c84f8fcde744d86e5dcd23c23b406bea.png)

这个时候再打开计算机设备管理器，就可以看到CP2102驱动程序已经安装成功了，刚刚那个黄色的感叹号不见了。

![](media/cb90d5f0fbe64d25436859f6505c653b.png)

IDE设置和工具栏介绍

装好了开发板的驱动，我们下面要了解Arduino开发软件的使用了，首先我们点击电脑桌面上的![](media/15ee1732a5c94b90c848898712b66390.png)图标，打开Arduino IDE，进行语言切换。单击“File”→“Preferences”，在 Preferences
页面中将语言“English”切换成“简体中文”，点击“OK”就可以了。

![](media/281b98ed7b10db9688743a790e86915c.png)

![](media/cbdf56227d11e10326df6ecc3c97c284.png)

关闭Arduino IDE再重启，这样，Arduino IDE页面中的语言就切换好了。

![](media/ac246dadf362809025df18223f3a3a98.png)

为了避免在将程序上载到板上时出现任何错误，必须选择正确的Arduino板名称，该名称与连接到计算机的电路板相匹配。转到“工具”→“开发板：”，然后选择你的板。

![](media/c8b00bbdbe56803bf2a8bdae9280356e.png)

然后再选择正确的COM口（安装驱动成功后可看到对应COM口）。

![](media/cb90d5f0fbe64d25436859f6505c653b.png)

![](media/7f816ac06eab5170372d40e8cad97e62.png)

我们的程序上传到板之前，我们必须演示Arduino IDE工具栏中出现的每个符号的功能。

![](media/ebd36a162fe0d8bd7d58e896d760a720.png)

A - 用于检查是否存在任何编译错误。

B - 用于将程序上传到Arduino板。

C - 用于创建新草图的快捷方式。

D - 用于直接打开示例草图之一。

E - 用于保存草图。

F - 用于从板接收串行数据并将串行数据发送到板的串行监视器。

启动你的第一个程序

上面我们学习了怎么下载软件和安装开发板的驱动，那下面我们就开始正式开始第一个程序，打开文件选择例子，选择第一个文件BASIC里面的BLINK程序

![](media/60432ab894550920eb433fbdd9f64358.png)

当草图窗口打开时，您可以在窗口中看到整个草图。

![](media/b0f166d2eca674ffd6968d39da1ee19b.png)

按照前面方法设置板和COM口，IDE右下角显示对应板和COM口。

![](media/af1e081620624a5c329d6833595d61ac.png)

![](media/31aa0b35fcb3601b6a83de1dac020893.png)

点击![](media/ddd21c81338ae1f6b7f84de2a3caecf0.png)图标开始编译程序，检查错误，检查无误。

![](media/6f1516bf7cd20f7467c5f4cbab6ec717.png)

点击![](media/9c9158a5d49baa740ea2f0048f655017.png)图标开始上传程序，上传成功。

![](media/bcb987be6c7fec8c06859c102168786c.png)

程序上传成功，板载的LED灯亮一秒钟，灭一秒钟，恭喜你的第一个程序完成了！

2.在MAC 系统上安装驱动

![](media/14306877671603761f7451ae0b2dc951.png)

#### 2.1下载安装arduino软件： 

![](media/5d58d3cf67b308423ddb9f286f6cb697.png)

#### 2.2如何安装CP2102驱动程序： 

（注意：如果已经安装了驱动程序，则不需要再安装驱动；如果没有，则需要进行以下操作）

（1）用USB线将Keyes Uno PLUS控制板连接到你的MacOS系统电脑上，并打开Arduino IDE。

![](media/a72fe5a29c6af0cd24aba7ab59b4996e.emf)

点击工具，选择主板:“Arduino Uno”，串口为
/dev/cu.usbserial-0001。

![](media/ef09ff03db61fbb040a09f798fcabb44.emf)

点击![](media/9c9158a5d49baa740ea2f0048f655017.png)上传代码，如果上传成功，如下图所示，会显示上传成功。

![](media/f76eccfb96fb58aee8e7ecba1621be28.emf)

注意：如果上传代码程序成功了，则不需要再安装驱动，可以跳过下面安装驱动的步骤；如果没有上传成功，则需要跟着下面的步骤安装CP2102驱动。执行下面（2）~（13）步。

（2）CP2102驱动下载链接：

<https://www.silabs.com/products/development-tools/software/usb-to-uart-bridge-vcp-drivers>

（3）点击下载MacOS 版本。

![](media/cfd3bb865e1d5a062d0c3f3ce14ce1ae.png)

（4）解压下载好的压缩包。

![](media/cdf2cf6787eb61aa211e0e46b67295ff.jpg)

（5）打开文件夹，双击SiLabsUSBDriverDisk.dmg文件。

![](media/570d0452818519cf67c7ac750032a901.emf)

可以看到以下文件。

![](media/3f1afe9499f6d852492cfb9d6b11e9ab.jpg)

（6）双击 Install CP210x VCP Driver 等待界面。

（7）点击Continue

![](media/3af43abbc2ef1050d6063b8c82589c6e.jpg)

（8）先点击Agree ，然后点击Continue

![](media/865dcc76cb7f58854b56f1020233f05e.jpg)

（9）继续点击Continue ，然后输入你的用户密码

![](media/1ef6d65b61ad7c6e0a3989ba59de74d5.jpg)

![](media/1204fca49aac9a5a2560f1865d59ca56.emf)

（10）回到安装界面，根据提示等待安装

![](media/0da6d0d4296d6e3de0b30dfd3c615265.jpg)

（11）安装成功

![](media/7cca827fe946096f228797dadce10661.jpg)

（12）打开arduinoIDE，点击工具，选择主板为Arduino Uno
，串口为/dev/cu.usbserial-0001

![](media/fb321aedfdd0e621f041b974e1d44d93.emf)

（13）然后再点击上传程序，就可以看到烧录成功。

![](media/f76eccfb96fb58aee8e7ecba1621be28.emf)

3. 库文件安装

在开始课程之前我们还需要安装课程里面代码需要的Arduino库文件。

什么是arduino库文件 ?

库是代码的集合，使您可以轻松地连接到传感器、显示器、模块等。

例如，内置的LiquidCrystal库使与字符LCD显示器的通话变得容易。
Internet上有数百个其他库可供下载。 参考中列出了内置库和其中一些其他库。
要使用其他库，您需要安装它们。

如何安装库文件?

在这里，我们将为您介绍最简单的添加库的方法。  
第一步： 下载Arduino IDE成功后，您可以右键单击Arduino IDE的图标。
选择“打开文件所在的位置(I)”就会进入安装目录，再点击进入libraries文件夹。

![](media/6f687f0f3390804b319de78e52094e58.png)

第二步：
你可以看到“libraries”文件夹所在的位置，这个文件夹里面就是Arduino的库文件。

![](media/d65edbf3dd79595c741e7e7049334e90.png)

第三步：打开我们提供的资料里面的
Libraries文件夹，复制粘贴到第二步我们打开的文件夹内。复制好了之后，我们的库文件就安装成功了，如下所示：

![](media/fa1870b60a56a45e1941a7b426692e22.png)

![](media/8170c15a3ee65e248327064c747c91d8.png)

< 

如果下载的是Arduino IDE 2.0版本，则Arduino IDE 2.0版本的库文件添加方式如下：

1.  现将提供的库文件都压缩成
    .ZIP格式，（这里以文件“Adafruit_NeoPixel”为演示过程，其他库文件的压缩方法是一样的。）

![](media/40b5dd31b1a2818aaaa57299bb963bc4.png)

![](media/a35f47442cae84472cfa08eaf54c85d0.png)

![](media/532a7eb7f385ccefa040df4b7d08efc4.png)

我们也提供了库文件的压缩包，也可以直接添加。

（2）在Arduino IDE2.0版本界面点击“项目”→“包含库”→“添加.ZIP库...”。

![](media/88ebb970ea96efb10d210a76e3d6a418.png)

（3）点击“打开”添加即可：（注意：库文件需要压缩为.ZIP格式；这里以“Adafruit_GFX_Library.ZIP”为演示，其他库文件的添加方法是一样的。）

![](media/bae953b820b4ba15fc962885c3f1a78f.png)

## 项目课程

### 第一课七彩灯

项目介绍：

![](media/d611b97a4d7d3bb26f373deb10aed2c4.png)首先我们要来完成经典的“Arduino点亮LED”，但是我们这里的LED，不是普通的单色LED，而是一个7彩LED，它采用7彩自动闪烁LED（外观白色，显示七彩）元件。7色LED模块可自动闪烁内置颜色。可以用来制作相当迷人的灯光效果。这个模块与普通LED驱动相同，当我们给它输入高电平时将自动闪烁七种颜色，而输入低电平时将停止闪烁。

我们已经将7彩LED集成到了我们的电机驱动底板，在第一个项目中，我们用一个最基本的测试代码来控制这个七彩LED，让它闪烁3秒钟，灭一秒钟，来实现控制的效果。你也可以改变代码中LED灯亮灭的时间，实现不同的闪烁时长效果。LED模块信号端S为高电平时7彩LED开始自动闪烁，S为低电平时七彩LED熄灭不再闪烁。

模块相关资料：

![](media/98d8992440974c7f5918c3e05f2da097.png)

![](media/2dfdc4dc411297bb863ef53217528fbc.png)

两个七彩灯分别通过三极管来控制，信号端分别接到了P5.4和P5.5，所以我们只要控制这两个引脚输出高低电平即可控制两个七彩灯。

实验结果：

首先我们先确保安装了库文件，不然代码会编译出错，这里我们用到库文件“MecanumCar_v2”，如何安装库文件请参考“开发环境配置”。编译上传代码完成后，将拨码开关拨到ON端上电，我们就可以看到底板的2个七彩LED闪烁3秒然后熄灭1秒，然后再次闪烁3秒再熄灭1秒，如此反复循环。

代码说明:

|#include "MecanumCar_v2.h"|导入MecanumCar_v2的头文件，然后我们才能使用这个库文件的一些接口函数|
|-|-|
|void setup()|一些初始化设置代码，这里的代码只运行一次|
|mecanumCar mecanumCar(sda, scl);|创建一个小车驱动的类实例，用来驱动小车的电机和七彩灯，sda接D3，scl接D2，可以更改接线|
|void loop()|主循环，相当于while(1)，这里面的代码反复循环运行|
|mecanumCar.Init();|初始化小车驱动。|
|mecanumCar.right_led(1); mecanumCar.right_led(0);|参数为1时，输出高电平到右边七彩灯的信号引脚，点亮；为0时，输出低电平到右边七彩灯的信号引脚，熄灭|
|mecanumCar.left_led(1); mecanumCar.left_led(0);|参数为1时，输出高电平到左边七彩灯的信号引脚，点亮；为0时，输出低电平到左边七彩灯的信号引脚，熄灭|
|delay(1000);|延时1000毫秒|

### 第二课 WS2812 RGB灯

项目介绍：

![](media/d1430e7b98db55d29eadb7e9ef16810e.jpg)在第一个项目，我们详细的介绍了通过代码控制七彩LED控制闪烁。这节课我们使用WS2812灯珠来显示真正的多彩灯，理论上我们可以通过编程实现我们想要显示的任意的颜色。

但是这个2812 RGB
驱动原理与我们前面学习过的七彩LED不相同，但是也只需要一个引脚就能控制，这是一个集控制电路与发光电路于一体的智能外控LED光源。每个LED原件其外型与一个5050LED灯珠相同，每个元件即为一个像素点，我们这个电机驱动板上有四个灯珠即四个像素。下面我们来学习如何控制它来显示任意颜色。

模块相关资料：

![](media/2fddc64a4a71932e4830248c1d6d778c.png)

这四个像素点灯珠都是串联起来的，其实不论多少个，我们都可以用一个引脚（我们这里接的D10）控制任意一个灯，并且让它显示任一种颜色。像素点内部包含了智能数字接口数据锁存信号整形放大驱动电路，还包含有高精度的内部振荡器和12V高压可编程定电流控制部分，有效保证了像素点光的颜色高度一致。数据协议采用单线归零码的通讯方式，像素点在上电复位以后，S端接受从控制器传输过来的数据，首先送过来的24bit数据被第一个像素点提取后，送到像素点内部的数据锁存器。这个2812RGB通讯协议与驱动已经在底层封装好了，我们直接调用函数的接口就可以使用。

实验结果：

首先我们先确保安装了库文件，不然代码会编译出错，这里我们用到库文件“Adafruit_NeoPixel”，如何安装库文件请参考“开发环境配置”。将拨码开关拨到ON端上电，上传代码完成，我们就可以看到底板的4个2812灯珠分显示红、绿、蓝、白色。

代码说明:

|#include <Adafruit_NeoPixel.h>|导入rgb_2818的头文件，然后我们才能使用这个库文件的一些接口函数|
|-|-|
|Adafruit_NeoPixel rgb_2812 = Adafruit_NeoPixel(num, pin, NEO_GRB + NEO_KHZ800);|创建一个rgb_2818灯驱动的类实例，用来驱动rgb_2818灯，pin接为引脚号，num为灯珠数量，我们这里接的D10 ,4个灯珠，所以是(4， 10).|
|rgb_2812.begin();|启动rgb2818|
|rgb.setBrightness(100);|设置灯珠亮度为100，范围为0~255，越大越亮|
|rgb_2812.clear();|初始化所有NeoPixels为“关闭”状态|
|rgb_2812.setPixelColor(num, r, g, b);|设置灯珠的颜色，num为灯珠号，4颗灯珠号分别为0、1、2、3；r,g,b为灯珠显示的颜色|
|rgb.show();|刷新显示，如果不调用该函数，设置的颜色不会更新|
|random(0, 255);|在0~255直接取随机数|

上传代码成功后，我们将看到4个灯珠以随机颜色显示流水灯。

### 第三课 伺服舵机

项目介绍：

![](media/d10643b01e46fb947581bb4bc22dea20.png)对于那些DIY智能汽车来说，往往都有自动避障的功能。在DIY过程中，我们需要一个伺服来控制超声波模块左右旋转，然后检测汽车与障碍物的距离，从而控制汽车避开障碍物。
如果使用其他微控制器来控制伺服的旋转，我们需要设置一定频率和一定宽度的脉冲来控制伺服角度。但是如果用arduino来控制伺服角度，我们只需要在开发环境中设置舵机的连接引脚然后设置控制角度即可。在开发环境中会自动设置相应的脉冲来控制伺服旋转。
在本项目中，您将学习如何控制伺服舵机在0°和180°之间来回旋转。

模块相关资料：

角度范围：0°~180°（有0°~360°舵机，0°~180°舵机，0°~90°舵机）

驱动电压：3.3V或5V

引脚一般为三根线

![](media/4b15604cd8a82aeb39497c7544b39f93.emf)

GND：一个接地的引脚，棕色

VCC：一个连接到+5v（3.3V）电源的引脚，红色

S：信号端的引脚，PWM信号控制，橙色（我们这里接到了D9）

控制原理：舵机的转动的角度是通过调节PWM（脉冲宽度调制）信号的占空比来实现的，标准PWM（脉冲宽度调制）信号的周期固定为20ms（50Hz），理论上脉宽分布应在1ms到2ms
之间。

![](media/29c43d352c12436ac6c5f9b4108ded5d.png)

但是，事实上脉宽可由0.5ms 到2.5ms
之间，脉宽和舵机的转角0°～180°相对应。有一点值得注意的地方，由于舵机牌子不同，对于同一信号，不同牌子的舵机旋转的角度也会有所不同。

![](media/4e9f169725398e11aba1bff347897339.png)

经过实测，舵机的脉冲范围为0.65ms~2.5ms。180度舵机，对应的控制关系是这样的：

|高电平时间|舵机角度|基准信号周期时间（20ms）|
|-|-|-|
|0.65ms|0度|0.65ms高电平+19.35ms低电平|
|1.5ms|90度|1.5ms高电平+18.5ms低电平|
|2.5ms|180度|2.5ms高电平+17.5ms低电平|

实验结果：

编译上传代码完成后，将拨码开关拨到ON端上电，我们就可以看到舵机从0度到180度之间来回转动了。

代码说明:

|#define servo_pin 9|定义舵机的引脚号为D9|
|-|-|
|pinMode(servo_pin, OUTPUT);|设置连接舵机的引脚为输出模式，设置完后可输出高/低电平。|
|servopulse(servo_pin, angle);|脉冲函数，使连接servo_pin引脚的舵机转动到angle角度位置。|
|map(myangle, 0, 180, 500, 2500);|映射函数，把myangle这个变量从0~180映射到500到2500，比如当myangle为90时，映射出来的值就是1500。|
|digitalWrite(pin, HIGH); digitalWrite(pin, LOW);|第一个参数pin为输出的引脚，第二个参数为HIGH时，输出高电平（3.3V）；为LOW时，输出低电平（0V）|
|delayMicroseconds(pulsewidth);|延时pulsewidth微秒|

项目拓展：
使用舵机库来驱动，使用前得先安装舵机文件

首先我们先确保安装了库文件，不然代码会编译出错，这里我们用到库文件“MecanumCar_v2”，如何安装库文件请参考“开发环境配置”。烧入代码后，将拨码开关拨到ON端上电，舵机在0~180度之间来回转动，一般我们使用舵机库来驱动，这样使用了定时器更精确。

### 第四课 直流减速电机

项目介绍： 

![](media/ee3eba2127f8b2607d91f1c7da36f12d.png)要想让小车跑起来那必须要有电机，然后搭配车轮就可以了。我们这个套件上配有4个直流减速电机，即[齿轮减速电机](https://baike.baidu.com/item/%E9%BD%BF%E8%BD%AE%E5%87%8F%E9%80%9F%E7%94%B5%E6%9C%BA/3249233)，是在普通[直流电机](https://baike.baidu.com/item/%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA/2404223)的基础上，加上配套齿轮减速箱。齿轮减速箱的作用是，提供较低的转速，较大的力矩。同时，[齿轮箱](https://baike.baidu.com/item/%E9%BD%BF%E8%BD%AE%E7%AE%B1/1059341)不同的[减速比](https://baike.baidu.com/item/%E5%87%8F%E9%80%9F%E6%AF%94/5341327)可以提供不同的转速和力矩。这大大提高了直流电机在自动化行业中的使用率，[减速电机](https://baike.baidu.com/item/%E5%87%8F%E9%80%9F%E7%94%B5%E6%9C%BA/3750851)是指[减速机](https://baike.baidu.com/item/%E5%87%8F%E9%80%9F%E6%9C%BA/873618)和电机（马达）的集成体，这种集成体通常也可称为[齿轮马达](https://baike.baidu.com/item/%E9%BD%BF%E8%BD%AE%E9%A9%AC%E8%BE%BE/7911602)或[齿轮电机](https://baike.baidu.com/item/%E9%BD%BF%E8%BD%AE%E7%94%B5%E6%9C%BA/3377578)。减速电机广泛应用于钢铁行业、机械行业等。使用减速电机的优点是简化设计、节省空间。

电机的驱动不比LED，它要求的电流比较大，如果我们使用IO口强制驱动电机，要么电机不转动，要么烧坏单片机，所以我们需要一个电机驱动芯片。在电机驱动底板板上已经包含了DRV8833电机驱动芯片，用来控制4个直流减速电机的转动方向和转动速度。我们下面来看一下电机驱动底板两个芯片的电路原理图：

模块相关资料：

![](media/ff4495f197508b2b161000b37f4a7ede.png)

![](media/3ae4d36064af4182156ceb7938e8f094.png)

每个芯片控制4个引脚，每两个引脚控制一个电机，这样就使用了8个引脚控制了4个电机了。我们可以看到电机驱动与STC的接线图，我们驱动电机的时候使用IIC协议往STC这个芯片对应的寄存器地址写入脉宽值就可以输出pwm信号给电机驱动芯片了，我们已经写好了电机驱动的库文件，我们使用的时候只需要调用API函数就可以让小车走了，非常简单。

实验代码：

实验结果：

首先我们先确保安装了库文件，不然代码会编译出错，这里我们用到库文件MecanumCar_v2，如何安装库文件请参考开发环境配置。编译上传代码完成后，将拨码开关拨到ON端上电，我们就可以看到小车前进2秒然后后退2秒，然后左转2秒再右转2秒，最后停止1秒，如此反复循环。

代码说明:

|#include "MecanumCar_v2.h"|导入MecanumCar_v2的头文件，然后我们才能使用这个库文件的一些接口函数，后面不再赘述|
|-|-|
|mecanumCar mecanumCar(sda, scl);|创建一个小车驱动的类实例，用来驱动小车的电机和七彩灯，sda接D3，scl接D2，可以更改接线，后面不再赘述|
|mecanumCar.Init();|初始化小车驱动，后面不再赘述。|
|mecanumCar.Advance();|调用此函数时，4个电机向前转，小车前进|
|mecanumCar.Back();|调用此函数时，4个电机向后转，小车后退|
|mecanumCar.Turn_Left();|调用此函数时，左边2个电机向后转，右边2个电机向前转，小车左旋转|
|mecanumCar.Turn_Right();|调用此函数时，左边2个电机向前转，右边2个电机向后转，小车右旋转|
|mecanumCar.Stop();|调用此函数时，4个电机停止转动，小车停止|
|delay(2000);|等待2秒，后面不再赘述|

### 第五课 循迹传感器

项目介绍：

![](media/53014398768ffcde739a903c40ce5336.png)巡线传感器实际上是红外传感器。
在小车驱动底板的前面有3路巡线，此处使用的组件是TCRT5000红外灯管。
其工作原理是利用红外光对颜色的不同反射率，然后将反射信号的强度转换为电流信号。
在检测过程中，黑色在高电平时处于活动状态，而白色在低电平时处于活动状态，即检测到黑色时或者近距离没有检测到物体时输出高电平，检测到白色或者光滑易反射光的物体时输出低电平。
检测高度为0-3厘米。
底板上方还有3个蓝色旋转电位器，通过旋转这些电位器，可以调节传感器的检测灵敏度。

模块相关资料：

工作电压: 3.3-5V (DC)

接口: 5PIN接口(我们接到了A0,A1,A2)

输出信号:
数字信号（模拟信号口也可以当数字信号用，A0相当于D13，A1相当于D14，以此类推。）

检测高度: 0-3 cm

原理：巡线传传感器的原理是利用红外线对颜色的反射率不一样，将反射信号的强弱转化成电流信号。上电时，发射二极管发射红外光，FB-为电位器，我们通过调整电位器给电压比较器LM339D的4、6、8脚提供一个阈值电压，这个电压值的大小可以根据实际情况来调试确定。而红外光敏二极管收到红外光的时候，会产生电流，并且随着红外光的从弱变强，电流会从小变大。当没有红外光或者说红外光很弱的时候，输出的信号接近VCC，通过LM339D比较器后，接收检测引脚输出一个高电平。当随着光强变大，电流变大，输出电压就会越来越小，当小到一定程度，接收检测引脚就会变为低电平。当红外信号发送到黑色轨道时，黑色因为吸光能力比较强，红外信号发送出去后就会被吸收掉，反射部分很微弱。白色轨道就会把大部分红外信号反射回来。也就是说检测到黑色或没检测到物体时，单片机信号端接收到高电平；检测到白色物体时，单片机信号端接收到低电平。

![](media/8e0808b818896309a4ec99642ef5f543.png)

实验结果：

编译上传代码完成后，将拨码开关拨到ON端上电，再打开串口监视器，我们可以看到在串口监视器是上打印的三路巡线传感器接收到的数字信号，当我们用白纸去遮挡它的时候，输出0，用黑纸或者悬空小车的时候，输出1：

![](media/5d2a32d0aa0fe23ba2b030a61cd665d7.png)

代码说明:

|#define SensorLeft A0|传感器引脚接口定义，例如这里我们左边接到A0|
|-|-|
|Serial.begin(9600);|启动串口监视器,并设置波特率为9600|
|pinMode(SensorLeft, INPUT);|设置引脚为输入模式，因为我们想要去读取循迹传感器输出的电平信号，所以我们设置为输入模式。|
|digitalRead(SensorLeft);|读取引脚的数字电平，当这个引脚为3.3V时我们读取到的值就是1，当这个引脚为0V时，我们读取到的值就是0，读取完我们这里用一个变量SL保存了|
|Serial.print("Left:");|USB串口监视器不换行打印“Left:”|
|Serial.println();|USB串口监视器换行打印|

### 第六课 循迹智能车

![](media/3dfc6aa251c882a04836cbcbf5a5f681.jpg)

项目介绍：

前面我们学习了循迹传感器和电机驱动的原理和应用，下面我们要结合这两个基本的循迹传感器和电机驱动来做一款循迹小车。

循迹，意思就是循着轨迹，也就是我们经常会看到的走黑线的循迹小车，原理是利用循迹传感器对路面黑色轨迹进行检测，并将路面检测信号反馈给控制主板。控制板对采集到的信号予以分析判断，及时控制驱动电机以调整小车转向，从而使小车能够沿着黑色轨迹自动行驶，实现循迹小车自动寻迹的目的，我们来看看下面的流程图就清晰了：

实验流程图：

![](media/900efa189803f0602b01f5fd172bb54c.emf)

实验结果：

代码烧录完成后,将拨码开关拨到ON端上电，我们把小车放在黑色循迹图上，小车就能沿着黑线行驶了.

代码说明:

|#define SensorLeftA0|引脚定义|
|-|-|
|pinMode(SensorLeft, INPUT);|设置引脚输入输出模式|
|mecanumCar.Init();|初始化电机驱动|
|SL = digitalRead(SensorLeft);|读取引脚电平信号，保存给变量|
|if (SM == HIGH)|如果读取到高电平|
|if (SL == LOW &amp;&amp; SR == HIGH)|如果左边为低电平且右边为高电平|
|else if (SR == LOW &amp;&amp; SL == HIGH)|否则如果右边为低电平且左边为低电平|

### 第七课 超声波传感器

项目介绍：

![](media/2d10f5e417b4b7fc28f20d52d6d317ac.png)HC-SR04超声波传感器像蝙蝠一样使用声纳来确定与物体的距离。它在一个易于使用的包装中提供了出色的非接触式范围检测，具有高精度和稳定的读数。它配有超声波发射器和接收器模块。
HC-SR04或超声波传感器正在广泛的电子项目中用于创建障碍物检测和距离测量应用以及各种其他应用。这里介绍了用Keyes UNO PLUS开发板和超声波传感器测量距离的简单方法，以及如何在arduino IDE中使用超声波传感器。

模块相关参数：

工作电压:+5V DC

静态电流: \<2mA

工作电流: 15mA

有效角度: \<15°

距离范围: 2cm – 400 cm

精度: 0.3 cm

测量角度: 30 degree

触发输入脉宽: 10us

原理：最常用的超声测距的方法是回声探测法，如图，超声波发射器向某一方向发射超声波，在发射时刻的同时计数器开始计时，超声波在空气中传播，途中碰到障碍物面阻挡就立即反射回来，超声波接收器收到反射回的超声波就立即停止计时。超声波也是一种声波，其声速V与温度有关。一般情况下超声波在空气中的传播速度为340m/s，根据计时器记录的时间t，就可以计算出发射点距障碍物面的距离s，即：s=340t/2：

(1)采用IO口TRIG触发测距，给至少10us的高电平信号;

(2)模块自动发送8个40khz的方波，自动检测是否有信号返回；

(3)有信号返回，通过ECHO输出一个高电平，单片机读取到高电平持续的时间就是超声波从发射到返回的时间。

![](media/8a94e0eef2c3055ebb7f1ae0483a1e9b.png)

超声波模块的电路图：

![](media/b573604e96ca595da17452d9b126f2ba.png)

实验结果：

编译上传代码成功后上电，打开串口监视器，我们可以在串口监视器中看超声波模块测得的距离，移动小车前面的障碍物，看到串口监视器中距离值也在发生变化，如下图：

![](media/07c1b1b2aa54dfa3e6c5116a95cccfff.png)

代码说明:

|#define EchoPin 13 #define TrigPin 12|超声波引脚接口定义，Trig接D12，Echo接D13|
|-|-|
|pinMode(EchoPin, INPUT); pinMode(TrigPin, OUTPUT);|Echo引脚设置为输入模式，Trig引脚设置为输出模式|
|pulseIn(EchoPin, HIGH);|这是arduino自带的一个函数，返回Echo引脚高电平的时间，单位为us。|
|pulseIn(EchoPin, HIGH) /58.2;|根据Echo高电平时间来计算声波往返路程，从而计算出前方障碍物的距离。|

### 第八课 超声波跟随智能车

![](media/96ad93f64a256a1fd2627d827ab8e1a9.jpg)

项目介绍：

前面我们学习了使用循迹传感器和电机来制作了一个自动巡线智能小车，这节课我们使用超声波传感器和电机来制作一个自动跟随智能小车，我们通过超声波传感器检测智能车和前方障碍物的距离，然后根据这一个数据控制两个电机的转动，从而控制智能车的运动状态，我们来看看下面的程序流程图就很清晰了：

实验流程图：

![](media/c74d8bfef83d370f3cec8201c85a676a.emf)

实验结果：

上传代码成功后，将拨码开关拨到ON端上电，小车就能直线跟随了，注意这里只是直线跟随。我们用手掌放在超声波前面，慢慢向前，小车就会跟着我们的手掌移动。

代码说明:

|myservo.write(90);|在开始的时候我们先让舵机转动到90度位置|
|-|-|
|int distance = get_distance();|定义一个整数变量用来保存测得的距离，后面根据这个距离来控制小车行驶|
|if (distance <= 15) { mecanumCar.Back(); }|测得的前面距离小于等于15cm时，小车后退|
|else if (distance <= 25) { mecanumCar.Stop(); }|否则前面距离小于等于25cm时，小车停止|
|else if (distance <= 45) { mecanumCar.Advance(); }|否则前面距离小于等于45cm时，小车前进|
|else { mecanumCar.Stop(); }|否则前面距离大于45cm时，小车停止|

### 第九课 超声波避障智能车

![](media/1683e5ce8f1185038f650da97a01f80a.jpg)

项目介绍：

在上个项目中，我们制作了一个超声波跟随智能车。实际上，利用同样的硬件，同样的接线方法，我们只需要更改一个测试代码就可以将跟随智能车变为避障智能车。超声波避障智能车，就是通过超声波传感器检测前方障碍物的距离，然后舵机云台转动检测到左右两边的距离，然后根据这一个数据控制四个电机的转动，从而控制智能车的运动状态，从而实现避障。

我们来看看下面的程序流程图就很清晰了：

实验流程图：

![](media/fba389b9f8eed3ac9822d0a732525657.emf)

实验结果：

上传代码成功后，将拨码开关拨到ON端上电，小车就能自动避障了，注意这里速度不要调得太大。当小车行驶过程中前方遇到障碍物，小车将停止，然后舵机云台转动到左边，测下左边的障碍物的距离；然后舵机云台转动到右边，测下右边的障碍物的距离，然后判断左边与右边障碍物的距离，那边更远，小车就往那边转弯，然后继续行驶。

代码说明:

|myservo.write(90);|在开始的时候我们先让舵机转动到90度位置|
|-|-|
|int distance = get_distance();|定义一个整数变量用来保存测得的距离，后面根据这个距离来控制小车行驶|
|myservo.write(180); distance_L = get_distance();|超声波转动到左边，测左边的距离，保存|
|myservo.write(0); distance_R = get_distance();|超声波转动到右边，测右边的距离，保存|
|myservo.write(90);|舵机回正到90度位置|
|if (distance_L > distance_R)|判断左右两边距离，谁更大|
|else { mecanumCar.Advance(); }|如果前方距离大于20cm时，小车继续直行。|

### 第十课 红外接收

项目介绍：

![](media/0d841fc1237e1ca8d85acc408ba5c561.png)毫无疑问，红外遥控在日常生活中随处可见，以至于很难想象没有它世界会变得怎样。它被用来控制各种家电，如电视、音响、录影机和卫星信号接收器。红外遥控是由红外发射和红外接收系统组成的，也就是一个红外遥控器和红外接收模块和一个能解码的单片机组成的。

红外接收我们用的是一个红外接收模块，主要由红外接收头组成，它是集接收、放大、解调一体的器件，它内部IC就已经完成了解调，能够完成从红外线接收到输出与TTL电平信号兼容的所有工作，输出的就是数字信号。接收器做成的红外接收模块只有三个引脚，信号线(由前面安装部分我们知道红外接收是与我们单片机的A3管脚相连的)，VCC，GND。与Keyes UNO PLUS开发板和其他单片机连接通信非常方便，我们这个实验就把红外遥控的键值打印到串口监视器上。

模块相关资料：

红外发射的遥控器发射的38KHz红外载波信号是由遥控器里的编码芯片对其进行编码。它是（NEC协议）以一段引导码，用户码，用户反码，数据码，数据反码组成，利用脉冲的时间间隔来区别是0还是1信号(560us低电平+560us高电平时被认为是信号0，560us低电平+1680us高电平时被认为是信号1)，而编码就是由这些0
、1信号组成。同一个遥控器的用户码是不变的，用数据码不同来分辨遥控器按的键不同。当按下遥控器按键时，遥控器发送出红外载波信号，红外接收器接收到信号时程序对载波信号进行解码，通过数据码的不同来判断按下的是哪个键。单片机由接收到的01信号进行解码，由此判断遥控器按下的是什么键，为了方便接收数据，我们在小车前后都板载了红外接收头，我们这里是接到了Keyes UNO PLUS开发板的A3管脚。

![](media/016535e485488f5c401b9e8f2a01da1f.png)

实验结果：

上传代码成功后，将拨码开关拨到ON端上电，打开串口监视器，拿出遥控器，对准红外接收传感器发送信号，即可看相应按键的键值，如果按键时间过长，容易出现乱码。

![](media/6b2b200deac37a70fd1c6dcb79cca3a0.png)

我们通过测试得出的数值，做了一个遥控器按键值表，方便以后使用：

![](media/ec330bb311a5948898aa1461c6384985.jpg)

代码说明:

|#include "ir.h"|导入红外接收的库文件|
|-|-|
|IR IRreceive(A3);|红外接收模块接A3|
|int key = IRreceive.getKey();|定义一个整型变量，用来保存红外遥控的键值|
|if (key != -1)|没有接收到红外遥控信号时，返回的键值是-1，所以我们当值不等于-1时打印|
|Serial.println(key);|换行打印键值|
|if (key == 64 &amp;&amp; flag == true) flag = false;|如果按下了OK键并且flag为真 将flag置为假，用来下次熄灭|
|else if (key == 64 &amp;&amp; flag == false) flag = true;|如果按下了OK键并且flag为假 将flag置为真，用来下次点亮|

项目拓展：使用一个OK键来控制七彩灯的亮灭

上传代码成功后，将拨码开关拨到ON端上电，当遥控器按下OK按键时,LED就会亮；再按一下OK按键时，LED就会灭。

### 第十一课 红外遥控智能车

![](media/6c4c7e1ec48694ae39fc068413751973.jpg)

项目介绍：

前面我们已经测试出红外遥控器各个按键对应的键值，这个项目我们就是使用红外遥控器来控制小车了，我们可以通过代码设置（键值），让对应的按键控制智能车对应的运动状态。

实验流程图：

![](media/1130c26f40fc0fb1376b191f59be40bb.emf)

实验结果：

上传代码成功后，将拨码开关拨到ON端上电，当我们按下遥控器上的![](media/fee67ed1a9ebeca9e3d4c73af92321f1.png)时，小车前进；当我们按下遥控器上的![](media/9f1ed9d53c1bb73d472dd57f4e25fd1b.png)时，小车左转；当我们按下遥控器上的![](media/de213abdf4bc48c2c0f4ca3b9ff51f1b.png)时，小车后退；当我们按下遥控器上的![](media/0c707a4f97ab0e9934f03938533408eb.png)时，小车右转；当我们按下遥控器上的![](media/32078092fc089e2716222221f4b4c541.png)时，小车停止。

代码说明:

|switch (key) { case num: ...... break; }|Switch语句，配合case使用，当括号里的变量为case后面的值时，执行case后面的语句|
|-|-|
|case 64: mecanumCar.Stop();|匹配到64时，执行小车停止程序|
|case 70: mecanumCar.Advance();|匹配到70时，执行小车前进程序|
|case 21: mecanumCar.Back();|匹配到21时，执行小车后退程序|
|case 68: mecanumCar.Turn_Left();|匹配到68时，执行小车左转程序|
|case 67: mecanumCar.Turn_Right();|匹配到67时，执行小车右转程序|

### 第十二课 蓝牙APP控制麦轮车

![](media/2f92f49590c63651d0791844b61f1a54.jpg)

项目介绍：

![](media/e196d876d3e9584ad5bb59da78a1bd1e.jpg)我们这个套件中有一个DX-BT24 5.1蓝牙模块，这个款蓝牙模块配置
256Kb 空间，遵循 V5.1 BLE蓝牙规范。支持AT指令，用户可根据需要更改串口波特率、设备名称等参数，使用灵活。支持UART接口，并支持蓝牙串口透传，
具有成本低、体积小、功耗低、收发灵敏性高等优点，只需配备少许的外围元件就能实现其强大功能。

在前面课程中，我们只是基本让该套件的模块/传感器实现单个功能，那我们能不能把所有功能合在一起呢？当然可以，在这一课程中，我们使用BT24蓝牙模块用一个代码把小车所有模块都结合起来，这里包含前面课程中讲到的除了红外遥控的所有功能，我们利用手机APP连接蓝牙模块，从而操控各种功能，简单方便。我们先通过APP连接蓝牙来读取APP界面上各按钮发送的控制字符。

模块相关资料：

蓝牙协议：Bluetooth Specification V5.1 BLE

工作频率：2.4GHz ISM band

通信接口：UART

供电电源：5V/3.3V

通信距离:40m

外观尺寸：27(L)mm x 13 (W)mm x 2(H) mm

蓝牙名称：BT24

串口参数：9600、8数据位、1停止位、无校验、无流控

工作温度：MIN:-40℃ - MAX:+85℃

DX-BT24模块同时支持 BT5.1 BLE 协议，可以同具备 BLE
蓝牙功能的 iOS 设备直
接连接，支持后台程序常驻运行。主要用于短距离的数据无线传输领域。避免繁琐的线缆
连接，能直接替代串口线。BT24 模块成功应用领域：

※ 蓝牙无线数据传输； ※ 手机、电脑周边设备； ※ 手持
POS 设备；

※ 医疗设备无线数据传输； ※ 智能家居控制； ※
蓝牙打印机；

※ 蓝牙遥控玩具； ※ 共享单车；

蓝牙接口说明：

![](media/cd97cf79ff5cdd5bbd78f4cc960d38e5.png)①STATE：状态脚

②RX：接收脚

③TX：发送脚

④GND：接地脚

⑤VCC：电源脚

⑥EN：使能脚

将蓝牙模块连接到开发板：

|Uno|BT24|
|-|-|
|TX|RX|
|RX|TX|
|VCC|5V|
|GND|GND|

APP：

有关APP的具体下载安装方法及使用方法，请参考文件夹“7. APP”。

![](media/ad21b94facdf9c3125400d646912ef1b.png)

实验结果：

注意：蓝牙模块的RXD、TXD、GND、VCC分别对应的接到 电机驱动扩展板上的TX、RX、G、5V，而蓝牙模块的STATE和BRK两引脚不需要接。蓝牙是直接插在电机驱动扩展板上的，注意一下方向，而且在上传代码之前不要插上蓝牙模块。上传代码完成后，插上蓝牙，注意蓝牙不要插反了。连接蓝牙模块和打开串口监视器，对准蓝牙模块按下手机APP按钮，我们可以看到APP按钮对应的控制字符，如下图。

![](media/674d0d00a7f3f6d628f082445e96fd2f.png)

代码说明:

|Serial1.begin(9600);|设置蓝牙串口波特率为9600，这里要注意Serial和Serial1的区别，因为我们用的串口0所以使用Serial1，使用串口1时则需使用Serial2，而Serial为USB串口，即串口监视器使用|
|-|-|
|Serial1.available()|如果接收到蓝牙数据，这个值就不为0|
|char ble_val = Serial1.read();|读取蓝牙串口的数据，因为我们发生的是字符数据，所以定义一个char类型的变量来保存|
|Serial.println(ble_val); Serial1.println(ble_val);|请注意这两句代码的区别，上面这句是输出到串口监视器，后面这句是输出数据到蓝牙模块|
|Serial1.readStringUntil('#');|读取蓝牙发送的一串字符串，遇到“#”停止读取，注意我们这里连续使用两条这样的语句，是因为我们进行调速时，发送的字符串比如为V#50#，所以我们第一次读到的是“V”（遇到#则停止）,第二次读到的值为“50”，注意这里读到的是字符串而不是整数值|
|String(speed_str).toInt();|将读取到的数字字符串转换为整数值|
|map(speed_Upper_L, 0, 100, 0, 255);|因为我们APP上发送的速度值为0~100，所以我们得将它映射到0~255的范围中|
|speed_Upper_L speed_Lower_L speed_Upper_R speed_Lower_R|这四个变量我们没有直接定义，因为它是包含在"MecanumCar_v2.h"头文件中，分别代表四个电机的速度值，范围为0~255|

综合项目：APP控制麦克纳姆轮智能车

烧入代码后，将拨码开关拨到ON端上电，我们连上蓝牙BT24，就可以使用手机APP来控制我们前面所学的一系列玩法了：

1.  点击![](media/9e74ac7cb7424cb3cc9a330c9664aaa6.png)开启七彩灯，再次点击这个按钮七彩灯就会关闭。

2.  点击![](media/0e95b34cb9787a65450ac7de99250259.png)会进入循迹模式，当想退出该模式时，再次点击该按钮。

3.  点击![](media/36671fadc495bf97554a7e945479e11b.png)会进入跟随模式、当想退出该模式时，再次点击该按钮。

4.  点击![](media/f28f956c8261bfd8f6ec9afd9bfa78ce.png)会进入避障模式，当想退出该模式时，再次点击该按钮。

5.  ![](media/00adc835c0a15a08e21601b06128b916.png)拉动这两个条幅回改变左边两个电机的速度，右边也是相同的操作方法。

6.  ![](media/a955e4b3e352c3f4ba763100517605e9.png)这几个按钮是用来切换底板下面4个2812灯珠颜色的，中间按钮为关闭功能。

7.  剩下其他的按钮全都是用来操控小车行驶的，跟其他按钮不同的是，这些按钮当我们按下时小车行驶，松开按钮时小车停止。

![](media/556a58a2ee1b67e1ea0c1a542eb26af2.jpg)
